package com.example.Driver.service.impl;

import java.io.IOException;
import java.nio.file.*;
import java.time.LocalDate;
import java.util.UUID;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import com.example.Driver.DTO.DriverDTO;
import com.example.Driver.Entity.Driver;
import com.example.Driver.Mappers.DriverMapper;
import com.example.Driver.repository.Driverrepository;
import com.example.Driver.service.Driverservice;

@Service
public class Driverserviceimpl implements Driverservice{
	private Driverrepository driverrepository;
	private DriverMapper driverMapper;
	
	public Driverserviceimpl(Driverrepository driverrepository,DriverMapper driverMapper) {
		this.driverrepository=driverrepository;
		this.driverMapper=driverMapper;
	}

	/**
	 * Saves a new driver to the system.
	 * <p>
	 * This method converts the provided {@link DriverDTO} into a {@link Driver} entity,
	 * then persists it using the driver repository. It returns the saved Driver entity,
	 * including any autogenerated fields (like ID).
	 * </p>
	 *
	 * @param driverDTO The data transfer object containing driver details to be saved.
	 * @return The saved {@link Driver} entity.
	 */
	@Override
	public DriverDTO save(DriverDTO driverDTO, MultipartFile image, MultipartFile licence) throws IOException {
				
	    Driver entity = new Driver();
	    // Copy fields from DTO
	    entity.setName(driverDTO.getName());
	    entity.setEmail(driverDTO.getEmail());
	    entity.setAddress(driverDTO.getAddress());
	    entity.setVehicleNumber(driverDTO.getVehicleNumber());
	    entity.setVehicletype(driverDTO.getVehicletype());
	    entity.setJoindate(driverDTO.getJoindate());
	    
	    
	    entity.setStatus(driverDTO.getStatus());

	    // ✅ Save files and set file paths
	    if (image != null && !image.isEmpty()) {
	        String imagePath = saveFile(image);
	        entity.setImagepath(imagePath); // this sets driver_image column
	    }

	    if (licence != null && !licence.isEmpty()) {
	        String licencePath = saveFile(licence);
	        entity.setLicencepath(licencePath); // this sets driver_licence column
	    }
	    
	    System.out.println("Image path to save: " + entity.getImagepath());
	    System.out.println("Licence path to save: " + entity.getLicencepath());


	    // ✅ Save to DB
	    Driver saved = driverrepository.save(entity);

	    // Return response DTO (optional)
	    DriverDTO result = new DriverDTO();
	    result.setId(saved.getId());
	    result.setName(saved.getName());
	    result.setEmail(saved.getEmail());
	   
	    return result;
	}

	private String saveFile(MultipartFile file) throws IOException {
	    String fileName = UUID.randomUUID() + "_" + file.getOriginalFilename();
	    Path uploadDir = Paths.get("uploads"); // Folder inside your project or custom path
	    Files.createDirectories(uploadDir);
	    Path filePath = uploadDir.resolve(fileName);
	    Files.copy(file.getInputStream(), filePath, StandardCopyOption.REPLACE_EXISTING);
	    return filePath.toString(); // Store this in DB
	}


	/**
	 * Retrieves all driver entities from the repository and maps them to DTOs.
	 *
	 * <p>This method fetches a list of all {@link Driver} entities stored in the database 
	 * via the {@code driverrepository}. It then converts each {@code Driver} entity into 
	 * a {@code DriverDTO} using the {@code driverMapper}, and returns the list of DTOs.</p>
	 *
	 * @return a list of {@link DriverDTO} objects representing all drivers in the system.
	 */
	@Override
	public List<DriverDTO> findAll() {
	    List<Driver> drivers = driverrepository.findAll();
	   return drivers.stream() 
	                  .map(driverMapper::enitytoDto)
	                  .collect(Collectors.toList());
	}

	/**
	 * Retrieves a driver by their unique ID.
	 * <p>
	 * This method searches for a {@link Driver} entity in the database using the provided ID.
	 * If the driver exists, it returns an {@link Optional} containing the driver; otherwise, it returns an empty {@link Optional}.
	 * </p>
	 *
	 * @param id The unique identifier of the driver to retrieve.
	 * @return An {@link Optional} containing the found {@link Driver} if it exists, or an empty {@link Optional} if not found.
	 */
	@Override
	public DriverDTO findById(int id) {
		// TODO Auto-generated method stub
		Optional<Driver> driverFound =driverrepository.findById(id);
		if(driverFound.isPresent()) {
			return this.driverMapper.enitytoDto(driverFound.get());
		}
		return null;
	}
	/**
	 * Deletes a driver by their unique ID.
	 * <p>
	 * This method removes the {@link Driver} entity with the specified ID from the database.
	 * If no driver exists with the provided ID, no action is performed.
	 * </p>
	 *
	 * @param id The unique identifier of the driver to be deleted.
	 * @return 
	 */
	@Override
	public boolean delete(int id) {
		try {
		driverrepository.deleteById(id);
		return true;
		}
		catch(Exception e) {
			return false;
		}
		
	}

	@Override
	public DriverDTO update(DriverDTO driverDTO) {
		  Driver existing = driverrepository.findById(driverDTO.getId()).orElse(null);
		    if (existing != null) {
		        existing.setName(driverDTO.getName());
		        existing.setEmail(driverDTO.getEmail());
		        existing.setAddress(driverDTO.getAddress());
		        existing.setVehicleNumber(driverDTO.getVehicleNumber());
		        
		        existing.setJoindate(driverDTO.getJoindate());
		        
		        existing.setStatus(driverDTO.getStatus());
		        existing.setVehicletype(driverDTO.getVehicletype());
		        
		        
		        driverrepository.save(existing);
		        return driverDTO;
		    } else {
		return null;
	}
	
	

	}

	
}
